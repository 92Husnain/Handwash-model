<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hand Cleanliness Classifier</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    #label-container div { margin: 6px 0; }
    button, select { padding: 10px 14px; cursor: pointer; margin-right: 8px; }
    video { border: 1px solid #ccc; margin-top: 12px; }
  </style>
</head>

<body>
  <h2>Hand Cleanliness Classifier</h2>
  <p>Select camera, click Start, allow camera, and the model will show predictions.</p>

  <label for="cameraMode">Camera:</label>
  <select id="cameraMode">
    <option value="user">Front Camera</option>
    <option value="environment">Back Camera</option>
  </select>

  <button onclick="start()">Start</button>
  <button onclick="switchCamera()">Switch</button>

  <div style="margin-top:12px;">
    <video id="video" width="320" height="240" autoplay playsinline muted></video>
    <canvas id="canvas" width="320" height="240" style="display:none;"></canvas>
  </div>

  <div id="label-container" style="margin-top:12px;"></div>

  <!-- Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>

  <!-- Custom JS -->
  <script>
    let model, maxPredictions;
    let stream = null;
    let currentFacingMode = "user"; // "user" = front, "environment" = back

    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const labelContainer = document.getElementById("label-container");
    const cameraModeSelect = document.getElementById("cameraMode");

    async function loadModelOnce() {
      if (model) return;
      const URL = "./model/";
      model = await tmImage.load(URL + "model.json", URL + "metadata.json");
      maxPredictions = model.getTotalClasses();

      labelContainer.innerHTML = "";
      for (let i = 0; i < maxPredictions; i++) {
        labelContainer.appendChild(document.createElement("div"));
      }
    }

    async function start() {
      await loadModelOnce();
      currentFacingMode = cameraModeSelect.value;
      await startCamera(currentFacingMode);
      window.requestAnimationFrame(loop);
    }

    async function switchCamera() {
      currentFacingMode = (currentFacingMode === "user") ? "environment" : "user";
      cameraModeSelect.value = currentFacingMode;
      await startCamera(currentFacingMode);
    }

    async function startCamera(facingMode) {
      // stop previous stream if any
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }

      const constraints = {
        audio: false,
        video: {
          facingMode: facingMode, // "user" or "environment"
          width: { ideal: 320 },
          height: { ideal: 240 }
        }
      };

      try {
        stream = await navigator.mediaDevices.getUserMedia(constraints);
      } catch (e) {
        // fallback if some devices don't support facingMode properly
        console.warn("Requested camera mode failed, falling back to default camera. Reason:", e);
        stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
      }

      video.srcObject = stream;
      await video.play();
    }

    async function loop() {
      // draw video to canvas (mirror front camera only)
      const flip = (currentFacingMode === "user");
      const w = canvas.width, h = canvas.height;

      ctx.save();
      if (flip) {
        ctx.scale(-1, 1);
        ctx.drawImage(video, -w, 0, w, h);
      } else {
        ctx.drawImage(video, 0, 0, w, h);
      }
      ctx.restore();

      await predict();
      window.requestAnimationFrame(loop);
    }

    async function predict() {
      const prediction = await model.predict(canvas);
      for (let i = 0; i < maxPredictions; i++) {
        const p = prediction[i];
        labelContainer.childNodes[i].innerText =
          `${p.className}: ${(p.probability * 100).toFixed(1)}%`;
      }
    }
  </script>
</body>
</html>
